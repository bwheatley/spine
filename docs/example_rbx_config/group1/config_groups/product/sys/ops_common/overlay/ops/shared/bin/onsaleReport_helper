#!/usr/bin/perl -w

$|=1;

use Getopt::Long;
use strict;

$::extraTime = 0;
$::colorIncrement = 1;
$::startTimeMarker = 1041411677;
$::endTimeMarker = 1041412277;

GetOptions(
        \%::commandLineOptions,
	'startTime|s=s',
	'endTime|e=s',
	'extraTime=s',
	'colorIncrement=s',
	'workDirectory=s',
);

unless (
	exists $::commandLineOptions{startTime}
		&&
	exists $::commandLineOptions{endTime}
) {
	die "need startTime & endTime";
}

$::extraTime = exists $::commandLineOptions{extraTime} ?
        $::commandLineOptions{extraTime} : $::extraTime;

$::colorIncrement = exists $::commandLineOptions{colorIncrement} ?
        $::commandLineOptions{colorIncrement} : $::colorIncrement;

$::startTimeMarker = $::commandLineOptions{startTime};
$::endTimeMarker = $::commandLineOptions{endTime};
$::startTime = $::commandLineOptions{startTime} - $::extraTime;
$::endTime = $::commandLineOptions{endTime} + $::extraTime;

my $dir = "/tmp/work";

my @clusters = (
	"lax1",
	"lax2",
	"ord1",
	"ord2",
	"ord3",
	"lhr1",
	"lca1",
	"cap1"
);

my $clusterRegexp = join("|", @clusters);

my @classes = (
	"app",
	"apt",
	"apx",
	"ate",
	"atl",
	#"auc",
	"cch",
	"dns",
	"edb",
	#"fed",
	"mgr",
	"mlb",
	"nta",
	"ops",
	"pwd",
	"pwq",
	"pxy",
	"sdb",
	"ses",
	"tfk",
	"tdb",
);

my @stats = (
	"orders",
	"cpu_idle",
	"httpd_accesses",
	"httpd_busy_workers",
	"httpd_bytes_out",
	"httpd_generation",
	"httpd_maint_workers",
	"httpd_max_mem_gap",
	"httpd_max_shared",
	"httpd_max_size",
	"httpd_min_shared",
	"httpd_min_size",
	"httpd_num_procs",
	"httpd_num_workers",
	"httpd_ready_workers",
	"cache_writes",
	"cache_hits",
	"cache_misses",
	"bytes_in",
	"bytes_out",
	#"cpu_aidle",
	"cpu_nice",
	#"cpu_num",
	"cpu_system",
	"cpu_user",
	"disk_free",
	#"disk_total",
	#"load_fifteen",
	#"load_five",
	"load_one",
	"mem_buffers",
	"mem_cached",
	"mem_free",
	"mem_shared",
	#"mem_total",
	"part_max_used",
	"pkts_in",
	"pkts_out",
	"proc_run",
	"proc_total",
	"swap_free",
	"shm_kbytes_used",
	"shm_inodes_used",
	#"swap_total",
);

my @colors = (
	"000000",

	"880000",
	"008800",
	"000088",

	"ff0000",
	"00ff00",
	"0000ff",

	"008888",
	"880088",
	"888800",

	"00ffff",
	"ff00ff",
	"ffff00",

	"888888",

	"ff8888",
	"88ff88",
	"8888ff",

	"88ffff",
	"ff88ff",
	"ffff88",
);

my $maxLength = 0;

foreach my $run (@ARGV) {
	if (length($run) > $maxLength) {
		$maxLength = length($run);
	}
}

foreach my $class (@classes) {
	print "\n$class";
	foreach my $stat (@stats) {
		print ".";
		&graphAverageByClass($class, $stat);
	}
}

foreach my $stat (@stats) {
	print "\n$stat";
	&graphAverageByStat($stat);
}

sub graphAverageByStat {
	my ($stat) = @_;

	my $colorIndex = 0;

	my $exec = "rrdtool graph" .
		" -s $::startTime -e $::endTime"
		. " -a PNG -t ${stat} ${stat}.png";
		#" -a PNG --step 15 -t ${class}_${stat} ${class}_${stat}.png";

	for my $class (sort @classes) {

		my @allHosts;

		foreach my $run (@ARGV) {
			opendir(RUN, "$dir/$run");
			my @hosts = grep { /^($clusterRegexp)?$class/ } readdir(RUN);
			@hosts = map {
				$_ =~ s#^#$run/#g;
				$_
			} @hosts;

			push(@allHosts, @hosts);
	
			closedir(RUN);
		}

		unless (@allHosts) { next; }

		my $average = "";

		my @allSafeHosts;
		my %duplicateHosts;

		foreach my $host (@allHosts) {

			unless (-f "$dir/$host/$stat.rrd") { 
				print STDERR "missing rrd:"
					. " [$dir/$host/$stat.rrd]\n";
				next;
			}
			if (`rrdtool fetch $dir/$host/${stat}.rrd AVERAGE -s $::startTime -e $::startTime` =~ m/nan/i) {
				print STDERR "no start data for rrd:"
					. " [$dir/$host/$stat.rrd]\n";
				next;
			}

			my $safeHost = $host;
			$safeHost =~ s/\W/_/g;
			$safeHost =~ s/_[^_]+_tmcs//g;

			if (exists $duplicateHosts{$safeHost}) { 
				print STDERR "duplicate safehost [$safeHost]\n";
				next;
			}
			++$duplicateHosts{$safeHost};

			push (@allSafeHosts, $host);

			$average .= " DEF:${safeHost}" .
				"=$dir/$host/${stat}.rrd" .
				":sum:AVERAGE";
		}

		unless (@allSafeHosts) { next; }

		my @CDEFS = @allSafeHosts;

		@CDEFS = map {
			$_ =~ s/\W/_/g;
			$_ =~ s/_[^_]+_tmcs//g;
			$_
		} @CDEFS;

		$average .= " CDEF:${class}ave=$CDEFS[0],";

		shift @CDEFS;

		if (@CDEFS) {
			$average .= join(",+,", @CDEFS) 
				. ",+," 
				. scalar(@allSafeHosts) 
				. ",/";
		} else {
			$average .= scalar(@allSafeHosts) 
				. ",/";
		}

		$average .= " LINE1:${class}ave#" 
			. $colors[
				int($colorIndex / $::colorIncrement)
			]
			. ":$class"
			. " GPRINT:${class}ave:MIN:min\\ %10.2lf"
			. " GPRINT:${class}ave:MAX:max\\ %10.2lf"
			. " GPRINT:${class}ave:AVERAGE:average\\ %10.2lf"
			. "\\ hosts\\ " . scalar(@allSafeHosts)
			. "\\\\n"
			. " VRULE:$::startTimeMarker#00ff00"
			. " VRULE:$::endTimeMarker#ff0000";

		$exec .= $average;

		++$colorIndex;
	}

	$exec .= " COMMENT:'" . localtime(time) . "'";

	#$exec =~ s/\ /\n/g;
	#print STDERR "\n stat " . $exec . "\n";
	`$exec`;
}

sub graphAverageByClass {
	my ($class, $stat) = @_;

	my $colorIndex = 0;

	my $exec = "rrdtool graph" .
		" -s $::startTime -e $::endTime"
		. " -a PNG -t ${class}_${stat} ${class}_${stat}.png";
		#" -a PNG --step 15 -t ${class}_${stat} ${class}_${stat}.png";

	for my $run (@ARGV) {
		my $safeRun = $run;
		$safeRun =~ s/\W/_/g;
		$safeRun =~ s/statRun//;
		my $spacer = $maxLength - length($run);
		$spacer = "\\ " x $spacer;

		opendir(RUN, "$dir/$run");
		my @hosts = grep { /^($clusterRegexp)?$class/ } readdir(RUN);
		closedir(RUN);

		unless (@hosts) { next; }

		my $average = "";

		my @safeHosts;
		my %duplicateHosts;

		foreach my $host (@hosts) {

			unless (-f "$dir/$run/$host/$stat.rrd") {
				print STDERR "missing rrd:"
					. " [$dir/$run/$host/$stat.rrd]\n";
				next;
			}
			if (`rrdtool fetch $dir/$run/$host/${stat}.rrd AVERAGE -s $::startTime -e $::startTime` =~ m/nan/i) {
				print STDERR "no start data for rrd:"
					. " [$dir/$run/$host/${stat}.rrd]\n";
				next;
			}

			my $safeHost = $host;
			$safeHost =~ s/\./_/g;
			$safeHost =~ s/_[^_]+_tmcs//g;

			if (exists $duplicateHosts{$safeHost}) {
				print STDERR "duplicate safehost [$safeHost}]\n";
				next;
			}
			++$duplicateHosts{$safeHost};

			push (@safeHosts, $host);

			$average .= " DEF:${safeRun}${safeHost}" .
				"=$dir/$run/${host}/${stat}.rrd" .
				":sum:AVERAGE";
		}

		unless (@safeHosts) {
			print STDERR "no valid hosts for"
				. " [$class],[$stat],[$run]\n";
			next; 
		}

		my @CDEFS = @safeHosts;

		@CDEFS = map {
			$_ =~ s/\W/_/g;
			$_ =~ s/_[^_]+_tmcs//g;
			"${safeRun}$_"
		} @CDEFS;

		$average .= " CDEF:${safeRun}ave=$CDEFS[0],";

		shift @CDEFS;

		if (@CDEFS) {
			$average .= join(",+,", @CDEFS) 
				. ",+," 
				. scalar(@safeHosts) 
				. ",/";
		} else {
			$average .= scalar(@safeHosts) 
				. ",/";
		}

		$average .= " LINE1:${safeRun}ave#" 
			. $colors[
				int($colorIndex / $::colorIncrement)
			]
			. ":$run"
			. " GPRINT:${safeRun}ave:MIN:${spacer}min\\ %10.2lf"
			. " GPRINT:${safeRun}ave:MAX:max\\ %10.2lf"
			. " GPRINT:${safeRun}ave:AVERAGE:average\\ %10.2lf"
			. "\\ hosts\\ " . scalar(@safeHosts)
			. "\\\\n"
			. " VRULE:$::startTimeMarker#00ff00"
			. " VRULE:$::endTimeMarker#ff0000";

		$exec .= $average;

		++$colorIndex;
	}

	$exec .= " COMMENT:'" . localtime(time) . "'";

	#$exec =~ s/\ /\n/g;
	#print STDERR "\n" . $exec . "\n";
	`$exec`;
}

# build indexes

open(INDEX, ">index.html") || die $!;

my $runTitles = join("<br>\n", @ARGV);

print INDEX "
<table>
	<tr>
		<th>&nbsp;</th>
		<th>By Class</th>
		<th>By Statistic</th>
	</tr>
	<tr>
		<td>
			<h1>Ganglia Graphs</h1>
			<h2>$runTitles</h2>
		</td>
		<td>
			<ul>
";

foreach my $class (@classes) {
	print INDEX "<li><a href=index_class_${class}.html>$class</a>\n";
}

print INDEX "
			</ul>
		</td>
";

my @statEntries = @stats;
while (@statEntries) {

	print INDEX "
		<td valign=Top>
			<ul>
	";

	my @stats = splice(
		@statEntries,0,scalar(@classes)
	);

	foreach my $stat (@stats) {
		print INDEX "<li><a href=index_stat_${stat}.html>$stat</a>\n";
	}
	print INDEX "
			</ul>
		</td>
		<td>
			<ul>
	";
}


print INDEX "
			</ul>
		</td>
	</tr>
</table>

";

foreach my $stat (@stats) {
	print INDEX "<img src=\"${stat}.png\">\n";
}

foreach my $class (@classes) {
	open(INDEX, ">index_class_${class}.html") || die $!;
	foreach my $stat (@stats) {
		print INDEX "<img src=\"${class}_${stat}.png\">\n";
	}
	close(INDEX);
}

foreach my $stat (@stats) {
	open(INDEX, ">index_stat_${stat}.html") || die $!;
	foreach my $class (@classes) {
		print INDEX "<img src=\"${class}_${stat}.png\">\n";
	}
	close(INDEX);
}

exit 0;
